# Clearledgr Project Rules

## IMPORTANT: Read MVP_SCOPE.md First

Before building anything, read `MVP_SCOPE.md` for the V1 scope definition.

**V1 = "Streak for AP"** - Invoice approval workflow inside Gmail + Slack.
**NOT V1:** Bank reconciliation, Sheets integration, PO matching.

## Project Overview
Clearledgr is an AI-powered finance operations platform that embeds into existing workflows (Gmail, Slack) to automate invoice processing. Target market: Growing companies (50-500 employees) using QuickBooks/Xero/NetSuite.

---

## Technical Spec: Clearledgr Gmail Extension

### Core Concept
An embedded agent that transforms the Gmail inbox into a "Finance Execution Layer." It doesn't just draft replies; it synchronizes unstructured email data with structured ERP/Bank state.

### 1. Identity & Context

**Persona:** A meticulous, audit-obsessed Finance Controller.

**UI Philosophy:** Embedded and "In-Situ." Actions happen inside the Gmail thread (Side-panel + Content Scripts) to eliminate context switching.

**The Moat:** Every action must be Stateful (via Temporal) and Verifiable (Audit Trail).

### 2. Feature Requirements

| Feature                    | Logic for LLM (Cursor)                                                                                                            |
| -------------------------- | --------------------------------------------------------------------------------------------------------------------------------- |
| Semantic Triage            | Scan incoming mail headers/bodies. Classify as INVOICE, REMITTANCE, EXCEPTION, or NOISE. Apply custom Gmail Labels automatically. |
| Data Extraction            | Use Vision/LLM to parse PDF/Image attachments. Extract: Vendor, Tax_ID, Amount, Currency, Line_Items.                             |
| ERP Sync (The "Execution") | Call ERP API (NetSuite/SAP) to check for matching Purchase Orders or Journal Entries.                                             |
| The "Action" Badge         | Inject a UI component into the email body: [MATCHED: Post to Ledger] or [EXCEPTION: Chase Vendor].                                |

### 2.1 Key Differentiators (CRITICAL)

These three features are what make Clearledgr genuinely better than generic email organizers:

| Differentiator | Implementation |
| -------------- | -------------- |
| **1. Audit-Link Generation** | When user clicks "Post" in Gmail, generate unique `Clearledgr_Audit_ID` (format: `CL-{date}-{hash}`). Append this ID as memo/note in ERP entry so auditors can trace transaction back to exact email. |
| **2. Human-in-the-Loop (HITL)** | If confidence score < 95%, DON'T show "Post" button. Show "Review Mismatch" instead with specific discrepancies (e.g., "Amount mismatch: Email says $105, Bank says $100"). |
| **3. Multi-System Routing** | When user approves invoice in Gmail, trigger TWO actions: (1) Post to ERP, (2) Update status of "Chasing" thread in Slack. Close the loop automatically. |

**Files implementing these:**
- `clearledgr/workflows/gmail_activities.py` - `generate_audit_id()`, `calculate_match_confidence()`, `update_slack_thread_activity()`
- `clearledgr/workflows/gmail_workflows.py` - `ApproveAndPostWorkflow` with HITL gate
- `clearledgr/api/gmail_extension.py` - `/approve-and-post`, `/verify-confidence`, `/escalate` endpoints
- `ui/gmail-extension/background.js` - `handleApproveAndPost()`, `handleVerifyConfidence()`, `handleEscalateToManager()`
- `ui/gmail-extension/sidebar.js` - Confidence-based button rendering, mismatch modal

### 3. Engineering Constraints

**Act as a Senior Full-Stack Engineer building the Clearledgr Chrome Extension.**
We are building an agentic finance layer for Gmail.

**Key Constraints:**

1. **State Management:** Every user action in Gmail must trigger a Temporal Workflow to ensure 100% execution reliability even if the tab closes.

2. **Verification:** Before suggesting a 'Post to Ledger' action, the agent must cross-reference the extracted email data against our 'Bank_Feed_Cache' and 'ERP_Registry'.

3. **UI:** Side-panel injected via Content Scripts. UI must feel like a native part of the Gmail interface.

4. **Security:** No sensitive financial data (PII) should be stored in cleartext. All ERP/Bank tokens must be handled via our secure backend.

### 4. Core Components

- **DiscoveryEngine:** Identifies if an open email thread contains a reconcile-able transaction
- **ExtractionPipeline:** Parses attachments and email body for financial data
- **MatchingEngine:** Cross-references against Bank_Feed_Cache and ERP_Registry
- **ActionBadge:** Injects contextual UI into email threads
- **WorkflowTrigger:** Initiates Temporal workflows for reliable execution

---

## Tech Stack
- **Frontend**: Vanilla HTML/CSS/JavaScript (no frameworks for demos)
- **Chrome Extension**: Manifest V3, service workers, content scripts
- **Backend**: Python/FastAPI (when running)
- **Integrations**: Gmail API, Google Sheets, Slack, SAP S/4HANA

## Code Style

### JavaScript
- Use ES6+ features (async/await, arrow functions, template literals)
- IIFE pattern for content scripts and sidebars to avoid global pollution
- Descriptive console.log with `[Clearledgr]` prefix for debugging
- Use `const` by default, `let` when reassignment needed
- Async functions for all API calls

### CSS
- Use inline styles for injected elements (Gmail compatibility)
- Use `!important` sparingly, only when overriding host page styles
- Prefer CSS variables for theming
- Mobile-responsive designs

### HTML
- Semantic HTML5 elements
- Inline SVG icons (no emoji in production UI)
- Accessible: proper labels, ARIA attributes

## Chrome Extension Specifics
- Always rebuild after changes: `cd ui/gmail-extension && bash build.sh`
- Test in `/dist` directory (unpacked extension)
- Use `chrome.storage.local` for persistence
- Use `chrome.runtime.sendMessage` for content<->background communication
- OAuth via `chrome.identity.launchWebAuthFlow` (not `getAuthToken`)

## Product Requirements
- All data must be consistent across surfaces (Gmail, Slack, Sheets)
- Support multiple currencies (USD, EUR, GBP, etc.)
- No hardcoded vendor/bank names - use generic terms or user config
- No emojis in professional UI - use SVG icons
- All buttons must be functional with realistic feedback

## File Structure
```
ui/
├── gmail-extension/     # Chrome extension source
│   ├── dist/           # Built extension (load this)
│   ├── manifest.json
│   ├── background.js   # Service worker
│   ├── content.js      # Injected into Gmail
│   ├── sidebar.html/js # Extension sidebar
│   └── build.sh        # Build script
├── slack/demo.html     # Slack simulator
└── sheets/demo.html    # Sheets simulator
website/                # Landing page (Vercel)
```

## Key Patterns

### Message Passing (Extension)
```javascript
// Content script -> Background
chrome.runtime.sendMessage({ action: "actionName", data: {} }, (response) => {});

// Background handler
chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
  if (request.action === "actionName") {
    handleAction(request).then(sendResponse);
    return true; // Keep channel open for async
  }
});
```

### Gmail API Calls
```javascript
async function gmailApi(endpoint, options = {}) {
  const token = await getGmailToken();
  const response = await fetch(`https://www.googleapis.com/gmail/v1/users/me${endpoint}`, {
    ...options,
    headers: { Authorization: `Bearer ${token}`, ...options.headers }
  });
  return response.json();
}
```

### Storage Pattern
```javascript
const KEY = "clearledgr_something";
async function getData() {
  return new Promise(resolve => {
    chrome.storage.local.get([KEY], result => resolve(result[KEY] || defaultValue));
  });
}
```

---

## Temporal Workflow Integration

The extension triggers backend Temporal workflows for reliable execution. Even if the browser tab closes, workflows complete.

### Architecture
```
Extension (background.js) 
    → API Call (FastAPI /extension/*)
        → Temporal Workflow (clearledgr-gmail task queue)
            → Activities (classify, extract, match, post)
```

### Task Queues
- `clearledgr-v1`: Core workflows (reconciliation, invoice processing)
- `clearledgr-gmail`: Gmail extension workflows (isolated for reliability)

### Temporal Worker (clearledgr/workflows/temporal_worker.py)
```python
# Two workers run concurrently:
# 1. Main worker for core workflows
worker = Worker(
    client,
    task_queue="clearledgr-v1",
    workflows=[ReconciliationWorkflowTemporal, InvoiceWorkflowTemporal, ...],
    activities=[reconciliation_match_activity, invoice_extraction_activity, ...],
)

# 2. Gmail extension worker (separate queue)
gmail_worker = Worker(
    client,
    task_queue="clearledgr-gmail",
    workflows=[EmailTriageWorkflow, EmailProcessingWorkflow, BulkEmailScanWorkflow, ApproveAndPostWorkflow],
    activities=[
        classify_email_activity,
        extract_email_data_activity,
        match_bank_feed_activity,
        match_erp_activity,
        verify_match_confidence_activity,  # HITL gate
        apply_gmail_label_activity,
        post_to_erp_activity,
        update_slack_thread_activity,      # Multi-system routing
        send_slack_notification_activity,
        create_mismatch_review_task_activity,
        audit_event_activity,
        route_exception_activity,
    ],
)

# Run both concurrently
await asyncio.gather(worker.run(), gmail_worker.run())
```

### Temporal Runtime (clearledgr/workflows/temporal_runtime.py)
```python
def temporal_enabled() -> bool:
    return TEMPORAL_AVAILABLE and os.getenv("TEMPORAL_ENABLED", "false").lower() == "true"

class TemporalRuntime:
    async def start_workflow(self, workflow_name, payload, task_queue, wait=True, timeout_seconds=30):
        client = await self._client()
        handle = await client.start_workflow(workflow_name, payload, id=workflow_id, task_queue=task_queue)
        if wait:
            return await handle.result()
        return {"workflow_id": workflow_id}
```

### Extension → Backend Flow
```javascript
// In background.js - trigger Temporal workflow
async function handleApproveAndPost(emailId, extraction, bankMatch, erpMatch, override) {
  // Try backend (Temporal workflow)
  if (!DEMO_MODE) {
    const result = await api("/extension/approve-and-post", {
      method: "POST",
      body: JSON.stringify({
        email_id: emailId,
        extraction,
        bank_match: bankMatch,
        erp_match: erpMatch,
        override,
        user_email: (await getCurrentUser())?.email
      })
    });
    return result;
  }
  // Fallback to demo mode
}
```

### API Endpoints (clearledgr/api/gmail_extension.py)
| Endpoint | Workflow | Purpose |
|----------|----------|---------|
| `POST /extension/triage` | `EmailTriageWorkflow` | Classify + extract single email |
| `POST /extension/process` | `EmailProcessingWorkflow` | Full processing with matching |
| `POST /extension/scan` | `BulkEmailScanWorkflow` | Batch inbox scan |
| `POST /extension/approve-and-post` | `ApproveAndPostWorkflow` | HITL approval + ERP post + Slack |
| `POST /extension/verify-confidence` | - | HITL confidence check |
| `POST /extension/escalate` | - | Send to Slack for manager review |

### Environment Variables
```bash
TEMPORAL_ENABLED=true
TEMPORAL_ADDRESS=localhost:7233
TEMPORAL_NAMESPACE=default
TEMPORAL_TASK_QUEUE=clearledgr-v1
```

---

## Gmail DOM Injection Best Practices (MV3)

Gmail's DOM changes frequently. Follow these patterns to avoid breakage:

### 1. Use MutationObserver for Dynamic Elements
```javascript
function waitForElement(selector, timeout = 10000) {
  return new Promise((resolve, reject) => {
    // Check if already exists
    const existing = document.querySelector(selector);
    if (existing) return resolve(existing);
    
    const observer = new MutationObserver((mutations, obs) => {
      const element = document.querySelector(selector);
      if (element) {
        obs.disconnect();
        resolve(element);
      }
    });
    
    observer.observe(document.documentElement, {
      childList: true,
      subtree: true
    });
    
    // Timeout fallback
    setTimeout(() => {
      observer.disconnect();
      reject(new Error(`Element ${selector} not found`));
    }, timeout);
  });
}
```

### 2. Prefer Stable Selectors (in order of stability)
```javascript
// BEST: role + data attributes (most stable)
'[role="main"]'
'[data-tooltip*="Send"]'
'[role="button"][data-action="send"]'

// GOOD: aria attributes
'[aria-label="Compose"]'
'[aria-haspopup="true"]'

// AVOID: class names (change frequently, sometimes per session)
'.T-I.J-J5-Ji'  // BAD - will break
```

### 3. Gmail-Specific Selectors (as of 2025)
```javascript
// Main content area
const GMAIL_MAIN = '[role="main"]';

// Email list container
const EMAIL_LIST = '[role="tabpanel"]';

// Compose button
const COMPOSE_BTN = '[gh="cm"]';

// Sidebar (left nav)
const SIDEBAR = '[role="navigation"]';

// Current email thread
const THREAD_VIEW = '[role="list"][data-legacy-thread-id]';
```

### 4. Inject Sidebar via iframe (Safest)
```javascript
// Don't inject directly into Gmail DOM - use iframe
function injectSidebar() {
  const sidebar = document.createElement('iframe');
  sidebar.id = 'clearledgr-sidebar';
  sidebar.src = chrome.runtime.getURL('sidebar.html');
  sidebar.style.cssText = `
    position: fixed !important;
    top: 0 !important;
    right: 0 !important;
    width: 380px !important;
    height: 100vh !important;
    border: none !important;
    z-index: 9999 !important;
  `;
  document.body.appendChild(sidebar);
}
```

### 5. Handle Gmail's SPA Navigation
```javascript
// Gmail is a Single Page App - URL changes don't reload
let lastUrl = location.href;
const urlObserver = new MutationObserver(() => {
  if (location.href !== lastUrl) {
    lastUrl = location.href;
    onGmailNavigate();  // Re-inject or update UI
  }
});
urlObserver.observe(document.body, { childList: true, subtree: true });
```

### 6. Verify Top-Level Frame
```javascript
// Only inject in main Gmail frame, not iframes
if (window.self !== window.top) return;
```

### 7. Content Script Manifest (manifest.json)
```json
{
  "content_scripts": [{
    "matches": ["https://mail.google.com/*"],
    "js": ["content.js"],
    "css": ["content.css"],
    "run_at": "document_idle",
    "all_frames": false
  }]
}
```

### 8. Graceful Degradation
```javascript
// Always wrap DOM operations in try-catch
try {
  const element = await waitForElement('[role="main"]');
  injectUI(element);
} catch (e) {
  console.warn('[Clearledgr] Gmail UI changed, falling back to sidebar-only mode');
  // Extension still works via sidebar
}
```

## Testing Checklist
- [ ] Extension loads without errors
- [ ] OAuth flow completes successfully
- [ ] Labels appear in Gmail sidebar
- [ ] Sidebar displays scanned emails
- [ ] Extracted data (vendor, amount, date) is accurate
- [ ] Due date warnings appear correctly
- [ ] Duplicate detection works

## Common Issues
1. **OAuth redirect_uri_mismatch**: Ensure Google Cloud Console has `https://<extension-id>.chromiumapp.org/` as redirect URI
2. **Labels not appearing**: Check `labelIdCache` is populated, verify Gmail API permissions
3. **Scan not running**: Check rate limiting (15 min default), force with `{action: "forceScan"}`

## Don't
- Don't use `chrome.identity.getAuthToken` (browser-specific issues)
- Don't store sensitive data in `chrome.storage.sync`
- Don't use emoji in production UI
- Don't commit OAuth client secrets
- Don't use placeholder data that doesn't match across surfaces
